# Paper2Code: Automating Code Generation from Scientific Papers in Machine Learning
- 论文地址：https://arxiv.org/html/2504.17192?_immersive_translate_auto_translate=1
- github代码仓库：https://github.com/going-doer/Paper2Code

## 介绍：
- 引入了 PaperCoder，这是一个基于多智能体 LLM 的框架，旨在自动生成可靠的机器学习代码库，直接基于研究论文并结合其语境，这与以往需要人工输入进行部分实现的工作不同。具体而言，PaperCoder 旨在模拟人类开发人员和研究人员编写代码库级代码的典型生命周期，将任务分解为三个结构化阶段：规划、分析和生成。首先，在规划阶段，该框架构建一个高级路线图以识别需要实现的核心组件，使用类图和序列图绘制整体系统架构以模拟模块之间的结构关系，识别文件依赖关系及其执行顺序以指导正确的构建和执行流程，并生成配置文件，以便人类研究人员灵活地定制实验工作流程。接下来是分析阶段，对每个文件和函数进行细粒度的解释，使其符合预期功能，例如所需的输入和输出、与其他模块的交互以及从源论文中衍生的任何算法或架构约束。最后，在生成阶段，框架根据先前确定的执行顺序以及前面阶段产生的工件来合成整个代码库。进一步分析表明，PaperCoder 的每个组件（包括规划、分析和生成）都有助于提升性能。
- 基于 LLM 的代码生成早期工作通常侧重于单文件任务，其目标是生成相对较短的代码片段来解决孤立的任务，例如（算法级）编程竞赛问题或玩具级编程查询 [ alphacode 、 humaneval 、 mbpp 、 apps ] 。然而，随着 LLM 在理解和生成具有执行长上下文推理能力的代码方面取得了进步，最近的研究越来越多地将注意力转向更具挑战性的存储库级编码任务，这些任务涉及生成多文件存储库，共同考虑架构设计、模块结构和文件间依赖关系 [ repobench 、 livecodebench 、 mlbench ] 。特别是，最近的一些努力探索了这种新兴范式 [ repocoder 、 repograph ] ，通常采用多代理或基于角色的框架来模拟现实的开发工作流程。例如，ChatDev 将 LLM 实例化为角色扮演代理，通过结构化对话进行协作 [ chatdev ] ，而 MetaGPT 则实现了瀑布式开发流程，其中专门的代理负责处理软件工程的不同阶段 [ metagpt ] 。除了前期工作之外，我们还探索了一项尚未充分探索但极具挑战性的任务：将完整的复杂论文转换为存储库级的实现。
- 即使对于功能强大的 LLM 来说，一次性生成完整、模块化且忠实的存储库（涵盖多个文件）也极具挑战性，这是由于科学论文及其相应实现的固有复杂性、当前模型的长上下文限制以及保持一致的全局结构和跨文件依赖关系的难度。因此，我们提出了一个多阶段和多代理框架，将整体任务分解为更小、更易于管理的子任务，每个子任务由针对论文到代码转换的特定方面量身定制的专门代理来处理。
- PaperCoder 框架，通过将任务分解为三个阶段来实现操作：（1）规划，根据论文构建高级实施计划，包括总体规划、架构设计、逻辑设计和配置文件；（2）分析，将计划转化为详细的文件级规范；（3）编码，生成最终代码以实现论文中的方法和实验。每个阶段由专门的 LLM 智能体进行协调.

## 架构：
形式上，给定一篇论文R，整个流程可以定义如下：
**P（plan）= F1（R），A（analysis）= F2（R,P）, C（coding）= F3（R，P，A**。其中 P 、A 和 C分别代表高层实现计划、详细的功能级分析和最终的代码仓库。

## Planning（规划阶段）
值得注意的是，与专为软件开发设计的实现规范不同，科学论文的写作目的是向人类传达想法和发现。因此，它们通常包含高层动机、有说服力的叙述和辅助细节，这些对于人类理解至关重要，但从软件工程的角度来看，它们可能存在噪声、规范不严谨或模棱两可的情况。为了应对这一挑战，我们引入了一个结构化规划阶段，将非结构化文本内容转换为实现级抽象。此外，我们将规划过程分解为四个连续的子组件（以简化任务并减少每个步骤中 LLM 驱动的智能体的认知和计算负载）：1) 总体规划，2) 架构设计，3) 逻辑设计，以及 4) 配置生成。我们将其正式定义为： 
**Mp(R)-->P={o,d,l,g}**，其中o是总体规划，d是架构设计，l是逻辑设计，g是配置文件，每个阶段都使用前一个阶段的输出作为上下文输入。然后，我们通过下面的具体目标和说明来描述如何实例化每个子组件。

### Overall Plan  总体规划
第一步是提取论文中描述的核心组件和功能的概要，以确定要实施的具体方法和实验。换句话说，这个概要概述涵盖模型组件、训练目标、数据处理步骤和评估方案（分布在整篇论文中），这些可以构成所有后续步骤的基础。

### Architecture Design  架构设计
根据提取的总体规划以及输入论文，下一步是定义存储库级架构，包括识别文件、将文件组织成模块以及定义它们之间的关系，以确保结构一致且易于维护。具体来说，LLM 驱动的代理将生成一个文件列表，用于概述存储库的整体文件结构；一个类图，用于详细说明文件的静态表示（例如核心类及其属性）；以及一个序列图，用于对动态交互进行建模。
#### 类图（Class Diagram）：
- 描述系统中的静态结构，即有哪些主要的“类”（Class）、它们的属性与方法，以及类与类之间的关系（如继承、关联、依赖、聚合、组合等）。
- 用于规划代码的包／模块划分、类接口设计、以及系统整体的层次结构。
- 在本例中：规划要在代码仓库里创建哪些核心类（例如数据加载器、模型定义、训练脚本、评估模块等），它们的属性（如配置参数、文件路径）与方法（如 load_data()、train()、evaluate()），以及各模块间的静态依赖。
#### 序列图（Sequence Diagram）
- 描述系统中各个对象或组件之间随时间推进的交互流程（动态行为）。
- 强调消息（方法调用、信号或返回）在不同对象间的先后顺序，帮助理解用例执行步骤或组件协作方式。
- 在本例中：描述从加载论文、解析结构化信息，到分阶段调用 LLM 生成代码、再到组装成最终可运行项目的各步骤交互，让团队（或 LLM 代理）清晰理解执行流程和数据流。

### Logic Design  逻辑设计
之前的架构设计侧重于构建什么，而逻辑设计阶段则通过考虑组件在整体执行流程中的依赖关系，来指定这些组件在实际中的实例化方式。换句话说，其主要目标是将架构设计中抽象的组件级关系转化为整个实现的可执行执行顺序。这一步至关重要，因为各个模块通常依赖于在代码库其他部分定义的共享实用程序、配置或数据加载器。如果没有明确定义的执行顺序，代码生成可能会导致失败或不一致（例如，当文件 B 从文件 A 导入模块时，文件 B 会在文件 A 之前生成）。为了解决这个问题，逻辑设计阶段不仅会生成一个有序的文件列表，用于规定文件的实现和执行顺序，还会进一步阐述每个文件中的逻辑，从而提供更细粒度的规范。
