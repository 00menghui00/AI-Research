
---

### **正确理解和使用聊天API的核心原则**

#### **原则一：API 本身是“无状态”的 (Stateless)**

这是最重要、最必须理解的一点。

*   **不记忆历史**：即使每次向同一个端点发送API请求，对于服务器来说都是一次全新的、独立的事件。服务器不会自动保存或“记住”你和它之前的任何对话。
*   **无内置会话**：API没有像网站登录那样的“会话”（Session）概念。你无法“登录”一个对话，然后再“退出”。

#### **原则二：上下文由“客户端”全权负责维护 (Client-Side Context Management)**

你所体验到的“连续对话”能力，完全是由你的代码（即客户端）在每次请求时主动构建和管理的。

*   **打包发送历史**：要让模型理解对话的上下文，你必须在每次请求时，将**从对话开始到当前的所有历史记录**（包括用户的提问 `user` 和模型的回答 `assistant`）按照时间顺序组织好，一起放在 `messages` 数组中发送给API。
*   **上下文是“燃料”**：你可以把对话历史看作是喂给模型的“燃料”。你喂给它完整的历史，它就能做出连贯的回应；你喂给它不完整的历史，它的回应就可能脱节；你不喂给它历史，它就认为这是一次全新的对话。

#### **原则三：通过控制 `messages` 数组来管理对话**

`messages` 数组是你控制模型行为的唯一“遥控器”。

*   **开启新对话**：要开始一个全新的、不受任何之前内容干扰的对话，只需构建一个**只包含当前第一条用户消息**的 `messages` 数组发送即可。
    ```python
    # 开启新对话
    messages = [
        {"role": "user", "content": "你好，请介绍一下自己。"}
    ]
    client.chat.completions.create(model="...", messages=messages)
    ```

*   **延续对话**：接收到模型的回复后，将你自己的新问题和模型的回复**都追加**到 `messages` 数组的末尾，然后再发送。
    ```python
    # 假设已有历史
    messages = [
        {"role": "user", "content": "你好，请介绍一下自己。"},
        {"role": "assistant", "content": "我是一个AI助手。"}
    ]
    # 追加新问题以延续对话
    messages.append({"role": "user", "content": "你能做什么？"})
    client.chat.completions.create(model="...", messages=messages)
    ```

*   **实现复杂应用（如Agent）**：在复杂的Agent工作流中，不同的任务节点（如“分析”、“编码”、“总结”）应该创建**各自独立、互不干扰**的 `messages` 数组。每个数组只包含完成当前特定任务所需的信息和指令，从而确保任务的专注和准确性，避免被其他任务的对话历史所污染。

---

